<script>
    //------------------------------------------------------------------------------------------------------------ETH PART
    // ethereum.on("error",function (Data)
    // {
    //     console.error("error",Data);
    // });
    // ethereum.on("message",function (Data)
    // {
    //     console.log("message",Data);
    // });

    var TESTMODE=0;
    var OLib;
    InitOrderLib();
    function InitOrderLib()
    {
        OLib=
            {
                WORK_PERIOD:10,//отступ от краев внутри разрешенного диапазона работы
                CACHE_DELTA:200,//delta for cache starting
                DeltaConfUpdate:1,
                eth : (new Web3(window.ethereum)).eth,
                WAS_ERR_MAP:{},
                ConfTera:undefined,
                WasMetaMaskInstalled:undefined,
                EthNetworkId:0,
                NetMapByGate:{},
                EthAddrFrom:undefined,
                EthABIERC:
                    [
                        //ERC20
                        {"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
                    ],

                EthABI:
                    [

                        //Proxy
                        {"inputs":[{"internalType":"address","name":"Address","type":"address"}],"name":"SetUpgrade","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[],"name":"SmartContract","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[],"name":"StartDeveloperMode","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"} ,

                        //Bridge
                        {"inputs":[{"internalType":"bytes","name":"Buf","type":"bytes"}],"name":"AddOrder","outputs":[],"stateMutability":"payable","type":"function"} ,
                        {"inputs":[{"internalType":"uint48","name":"ID","type":"uint48"}],"name":"CancelOrder","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[],"name":"DeleteLastNotary","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"bytes","name":"Buf","type":"bytes"}],"name":"ExecOrder","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[],"name":"GetCommon","outputs":[{"components":[{"internalType":"uint8","name":"WORK_MODE","type":"uint8"},{"internalType":"uint8","name":"CONSENSUS_PERIOD_TIME","type":"uint8"},{"internalType":"uint32","name":"FIRST_TIME_BLOCK","type":"uint32"},{"internalType":"uint24","name":"MAX_SIGN_PERIOD","type":"uint24"},{"internalType":"uint24","name":"MAX_TRANSFER_PERIOD","type":"uint24"},{"internalType":"uint8","name":"NOTARY_COUNT","type":"uint8"},{"internalType":"uint8","name":"MIN_SIGN_COUNT","type":"uint8"},{"internalType":"uint48","name":"MinNotaryFee","type":"uint48"},{"internalType":"uint48","name":"NotaryFee","type":"uint48"},{"internalType":"uint48","name":"MinDeposit","type":"uint48"},{"internalType":"uint16","name":"SlashRate","type":"uint16"},{"internalType":"uint48","name":"MinSlash","type":"uint48"},{"internalType":"uint8","name":"OrderEnum","type":"uint8"}],"internalType":"struct TypeLib.TypeCommon","name":"","type":"tuple"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[],"name":"GetConf","outputs":[{"components":[{"internalType":"uint48","name":"WorkNum","type":"uint48"},{"internalType":"uint48","name":"HeadOrderID","type":"uint48"},{"internalType":"uint48","name":"TailOrderID","type":"uint48"},{"internalType":"uint48","name":"NewOrderID","type":"uint48"}],"internalType":"struct TypeLib.TypeConf","name":"","type":"tuple"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[{"internalType":"uint32","name":"Num","type":"uint32"}],"name":"GetGate","outputs":[{"components":[{"internalType":"uint8","name":"WORK_MODE","type":"uint8"},{"internalType":"uint8","name":"TypeERC","type":"uint8"},{"internalType":"uint48","name":"Rate","type":"uint48"},{"internalType":"address","name":"TokenAddr","type":"address"},{"internalType":"uint8","name":"Decimals","type":"uint8"}],"internalType":"struct TypeLib.TypeGate","name":"","type":"tuple"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[{"internalType":"uint8","name":"Num","type":"uint8"}],"name":"GetNotary","outputs":[{"components":[{"internalType":"uint8","name":"Notary","type":"uint8"},{"internalType":"address","name":"Addr","type":"address"},{"internalType":"uint8","name":"CanSign","type":"uint8"},{"internalType":"uint64","name":"SumDeposit","type":"uint64"}],"internalType":"struct TypeLib.TypeNotary","name":"","type":"tuple"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[{"internalType":"uint48","name":"ID","type":"uint48"}],"name":"GetOrder","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"} ,
                        {"inputs":[{"internalType":"uint48","name":"ID","type":"uint48"},{"internalType":"uint8","name":"Notary","type":"uint8"},{"internalType":"bytes32","name":"SignR","type":"bytes32"},{"internalType":"bytes32","name":"SignS","type":"bytes32"},{"internalType":"uint8","name":"SignV","type":"uint8"}],"name":"NotarySign","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"components":[{"internalType":"uint8","name":"WORK_MODE","type":"uint8"},{"internalType":"uint8","name":"CONSENSUS_PERIOD_TIME","type":"uint8"},{"internalType":"uint32","name":"FIRST_TIME_BLOCK","type":"uint32"},{"internalType":"uint24","name":"MAX_SIGN_PERIOD","type":"uint24"},{"internalType":"uint24","name":"MAX_TRANSFER_PERIOD","type":"uint24"},{"internalType":"uint8","name":"NOTARY_COUNT","type":"uint8"},{"internalType":"uint8","name":"MIN_SIGN_COUNT","type":"uint8"},{"internalType":"uint48","name":"MinNotaryFee","type":"uint48"},{"internalType":"uint48","name":"NotaryFee","type":"uint48"},{"internalType":"uint48","name":"MinDeposit","type":"uint48"},{"internalType":"uint16","name":"SlashRate","type":"uint16"},{"internalType":"uint48","name":"MinSlash","type":"uint48"},{"internalType":"uint8","name":"OrderEnum","type":"uint8"}],"internalType":"struct TypeLib.TypeCommon","name":"Conf","type":"tuple"}],"name":"SetCommon","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"uint32","name":"Num","type":"uint32"},{"components":[{"internalType":"uint8","name":"WORK_MODE","type":"uint8"},{"internalType":"uint8","name":"TypeERC","type":"uint8"},{"internalType":"uint48","name":"Rate","type":"uint48"},{"internalType":"address","name":"TokenAddr","type":"address"},{"internalType":"uint8","name":"Decimals","type":"uint8"}],"internalType":"struct TypeLib.TypeGate","name":"Gate","type":"tuple"}],"name":"SetGate","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"uint8","name":"Notary","type":"uint8"},{"internalType":"bytes","name":"Addr","type":"bytes"},{"internalType":"uint64","name":"Deposit","type":"uint64"},{"internalType":"uint8","name":"CanSign","type":"uint8"}],"name":"SetNotary","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"SetOwner","outputs":[],"stateMutability":"nonpayable","type":"function"} ,
                        {"inputs":[{"internalType":"bytes","name":"Buf","type":"bytes"},{"internalType":"uint8","name":"Notary","type":"uint8"},{"internalType":"bytes32","name":"SignR","type":"bytes32"},{"internalType":"bytes32","name":"SignS","type":"bytes32"},{"internalType":"uint8","name":"SignV","type":"uint8"}],"name":"SlashProof","outputs":[],"stateMutability":"nonpayable","type":"function"} ,

                    ]
            };

        OLibClearCahce();

        setInterval(OLibClearCahce, 1200*1000);

    }

    function OLibClearCahce()
    {
        OLib.ConfTeraTime=0;
        OLib.ConfEthTime=0;
        OLib.MAP_ETH={};
        OLib.MAP_TERA={};
        OLib.GATE_MAP_ETH={};
        OLib.HistoryOrderArrTera=[{Arr:[],WorkNum:-1}];
    }


    function GetAddrFromPubKey(PubKeyArr)
    {
        return keccak256(PubKeyArr.slice(1)).slice(12);
    }

    //--------------------------------------------------------------------------- TX CATCHE
    function UpdateTeraCache(Data)
    {
        var Order=Data;
        if(typeof Data.cmd==="string")
            Order=Data.Data;
        if(Order && typeof Data.ID==="number")//update cache
        {
            delete OLib.MAP_TERA[Data.ID];
            delete OLib.MAP_ETH[Data.ID];
        }
    }


    async function GetOrderFromMap(Map,ID,F)
    {
        var BlockNum=GetOrderBlockNum({ID:ID})


        var Order=undefined;
        var bCacheMode=0;
        if(BlockNum<=INFO.CurBlockNum-OLib.CACHE_DELTA || TESTMODE)//find in cache
            bCacheMode=1;
        if(bCacheMode)
        {
            Order=Map[ID];
        }


        if(!Order)
        {
            Order=await F(ID);
            if(bCacheMode)
            {
                if(Order)
                    Map[ID]=Order;
                else
                    delete Map[ID];
            }
        }


        SetOrderPeriod(Order);
        return Order;
    }

    //--------------------------------------------------------------------------- ETH Send
    function DecodeEthObject(ObjEth,ToNum)
    {
        if(!ObjEth)
            return undefined;
        var Ret={};
        for(var key in ObjEth)
        {
            if(isNaN(+key))
            {
                if(ToNum)
                    Ret[key]=+ObjEth[key];
                else
                    Ret[key]=ObjEth[key];
            }
        }
        return Ret;
    }


    function Eth16(Sum)
    {
        return (Math.floor(Sum*1000000000000000000)).toString(16);
    }
    function GasPrise()
    {
        return ethereum.request({ method: 'eth_gasPrice',params:[] });
    }

    async function ConnectEth(ABI,Addr)
    {
        // get all accounts
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' })
        if(typeof accounts!=="object")
            return undefined;
        OLib.EthAddrFrom=accounts[0];

        //console.log("OLib.ContractAddr:",OLib.ContractAddr);
        if(!OLib.ContractAddr)
            return undefined;

        return new OLib.eth.Contract(ABI, Addr);
    }


    async function CallEthExt(MethodName,Arr,EthSmart)
    {
        if(OLib.WasMetaMaskInstalled===undefined)
        {
            OLib.WasMetaMaskInstalled=await ethereum.isMetaMaskInstalled();
            if(!OLib.WasMetaMaskInstalled)
                console.log("No Metamask");
        }

        if(!OLib.WasMetaMaskInstalled)
            return undefined;
        if(!EthSmart)
        {
            EthSmart=await ConnectEth(OLib.EthABI,OLib.ContractAddr);
        }
        if(!EthSmart)
            return undefined;




        var fun=EthSmart.methods[MethodName];


        try
        {
            var Ret=await fun.apply(this,Arr).call();
        }
        catch(err)
        {
            if(!OLib.WAS_ERR_MAP[MethodName])
            {
                console.log("Error on MethodName:",MethodName,Arr);
                OLib.WAS_ERR_MAP[MethodName]=1;
                console.error(err);
            }
            return undefined;
        }

        return Ret;
    }


    async function CallEthERC(Addr, MethodName)
    {
        var EthSmart=await ConnectEth(OLib.EthABIERC,Addr);

        var Arr=[];
        for(var i=2;i<arguments.length;i++)
            Arr.push(arguments[i]);

        return CallEthExt(MethodName,Arr, EthSmart);
    }

    async function CallEth(MethodName)
    {
        var Arr=[];
        for(var i=1;i<arguments.length;i++)
            Arr.push(arguments[i]);

        return CallEthExt(MethodName,Arr);
    }



    async function SendEthExt(MethodName, Arr, EthSmart)
    {
        if(!EthSmart)
            EthSmart=await ConnectEth(OLib.EthABI,OLib.ContractAddr);

        var fun=EthSmart.methods[MethodName];
        var Ret=fun.apply(this,Arr).send({from: OLib.EthAddrFrom});
        return Ret;
    }


    async function SendEthERC(Addr,MethodName)
    {
        var EthSmart=await ConnectEth(OLib.EthABIERC,Addr);

        var Arr=[];
        for(var i=2;i<arguments.length;i++)
            Arr.push(arguments[i]);

        return SendEthExt(MethodName, Arr, EthSmart);
    }


    async function SendEth(MethodName)
    {
        var Arr=[];
        for(var i=1;i<arguments.length;i++)
            Arr.push(arguments[i]);

        return SendEthExt(MethodName, Arr);
    }



    async function PayEth()
    {
        var EthSmart=await ConnectEth(OLib.EthABI,OLib.ContractAddr);

        var MethodName=arguments[0];
        var Value=arguments[1];
        var Arr=[];
        for(var i=2;i<arguments.length;i++)
            Arr.push(arguments[i]);

        var fun=EthSmart.methods[MethodName];
        var Ret=fun.apply(this,Arr).send({from: OLib.EthAddrFrom,value:Value});
        //console.log(MethodName+":",await Ret);
        return Ret;
    }



    function SetOwnerEth(Addr)
    {
        return SendEth("SetOwner",ToBytes(Addr));
    }




    //--------------------------------------------------------------------------- ETH Conf support

    async function GetCommonEthInner()
    {
        let Conf=await CallEth("GetCommon");

        Conf=DecodeEthObject(Conf,1);

        Conf.MinNotaryFee=Conf.MinNotaryFee/1e9;
        Conf.NotaryFee=Conf.NotaryFee/1e9;
        Conf.MinDeposit=Conf.MinDeposit/1e9;
        Conf.MinSlash=Conf.MinSlash/1e9;

        return Conf;
    }
    async function GetGateEthInner(Num)
    {
        let Conf=await CallEth("GetGate",Num);
        if(!Conf || Conf.Rate=="0")
            return undefined;

        Conf=DecodeEthObject(Conf,0);

        Conf.WORK_MODE=+Conf.WORK_MODE;
        Conf.TypeERC=+Conf.TypeERC;
        Conf.Rate=(+Conf.Rate)/1e9;
        Conf.Decimals=+Conf.Decimals;

        return Conf;
    }




    async function GetCommonEth(bForceUpdate)
    {
        if(bForceUpdate || !OLib.ConfEth || !OLib.ConfEthTime || (Date.now()-OLib.ConfEthTime)>OLib.DeltaConfUpdate*1000)
        {
            OLib.ConfEth=await GetCommonEthInner();
            OLib.ConfEthTime=Date.now();
        }

        //console.log("ConfEth:",OLib.ConfEth);

        return OLib.ConfEth;
    }

    async function GetGateEth(Num,bForceUpdate)
    {
        if(!OLib.GATE_MAP_ETH)
            OLib.GATE_MAP_ETH={};
        let Item=OLib.GATE_MAP_ETH[Num];
        if(!Item)
        {
            Item={Time:0,Data:undefined};
            OLib.GATE_MAP_ETH[Num]=Item;
        }

        if(bForceUpdate || (Date.now()-Item.Time)>OLib.DeltaConfUpdate*1000)
        {
            Item.Data=await GetGateEthInner(Num);
            Item.Time=Date.now();
        }

        //console.log("GetGateEth:",Num,Item);

        return Item.Data;
    }


    function SetCommonEth(Conf)
    {
        return SendEth("SetCommon",Conf);
    }

    async function GetConfEth()
    {
        var Conf=await CallEth("GetConf");
        return DecodeEthObject(Conf,1);
    }







    //--------------------------------------------------------------------------- ETH Order support
    function SendExecOrderEth(Order)
    {
        var Buf=[];
        EncodeOrder(Buf,Order,1);
        console.log("ETH Length:",Buf.length,ToBytes(Buf));
        return SendEth("ExecOrder",ToBytes(Buf));
    }


    async function SendAddOrderEth(Order)
    {
        var Common=await GetCommonEth();
        if(!Common)
            return SetError("Error GetCommonEth");

        if(!Order.ID)
            Order.ID=0;
        if(!Order.TokenID)
            Order.TokenID=[];

        var Buf=[];
        EncodeOrder(Buf,Order,1);


        var Gate=await GetGateEth(Order.Gate);
        if(!Gate || !Gate.Rate)
            return SetError("Error order Gate "+Order.Gate);




        //доводим точность до точности монеты
        if(Gate.TypeERC==0)//native eth
        {
            var AllAmount=Order.Amount+Order.TransferFee + Order.NotaryFee/Gate.Rate;
            AllAmount=AllAmount*(10**Gate.Decimals);

            console.log("ETH PAY:"+AllAmount/1e18+" Length:",Buf.length,ToBytes(Buf));

            return PayEth("AddOrder",AllAmount,ToBytes(Buf));
        }
        else
        if(Gate.WORK_MODE==3)//other token
        {
            var AllAmount=Order.Amount+Order.TransferFee + Order.NotaryFee;
            AllAmount=AllAmount*(10**Gate.Decimals);

            var WasAllowance=await CallEthERC(Gate.TokenAddr,"allowance",ToBytes(Order.AddrEth),ToBytes(OLib.ContractAddr));

            console.log("ERC:",AllAmount,"->",WasAllowance,WasAllowance<AllAmount?"NO":"OK");

            if(WasAllowance<AllAmount)
            {
                console.log("Start approve to "+Gate.TokenAddr);

                // if(WasAllowance>0)
                //      await SendEthERC(Gate.TokenAddr,"approve",OLib.ContractAddr,0);
                // var Result=await SendEthERC(Gate.TokenAddr,"approve",OLib.ContractAddr,AllAmount);

                WasAllowance=+WasAllowance;
                if(AllAmount>WasAllowance)
                {
                    var Result=await SendEthERC(Gate.TokenAddr,"approve",OLib.ContractAddr,AllAmount);
                    console.log("Result approve:",Result);
                }
            }
        }

        console.log("ETH Send Length:",Buf.length,ToBytes(Buf));
        return SendEth("AddOrder",ToBytes(Buf));

    }




    async function ReadOrderEth(ID)
    {
        var OrderBuf=await GetOrderFromMap(OLib.MAP_ETH,ID,async function(ID)
        {
            return CallEth("GetOrder",ID);
        });

        if(!OrderBuf || OrderBuf.length<=10)
            return undefined;
        else
        {
            //console.log("ID:"+ID,"Buf:",OrderBuf);
            return DecodeOrder(ArrFromBytes(OrderBuf),1)
        }
    }

    async function GetOrderListEth()
    {
        var Arr=[];
        var Conf=await GetConfEth();
        if(!Conf)
            return Arr;

        var TailOrderID=Conf.TailOrderID;

        var NextID=Conf.HeadOrderID;
        while(NextID)
        {
            var Order=await ReadOrderEth(NextID);

            if(Order && Order.ID)
            {
                if(Order.ID===TailOrderID && OLib.MAP_ETH[Order.NextID])
                {
                    console.log("remove from eth cache",Order.NextID);
                    delete OLib.MAP_ETH[Order.NextID];
                }


                Arr.push(Order);
            }

            if(Order)
            {
                NextID=Order.NextID;
            }
            else
            {
                NextID=0;
            }
            if(Arr.length>5000)
                break;
        }

        return Arr;
    }








    //------------------------------------------------------------------------------------------------------------TERA PART



    async function GetConfTera(Params,bForceUpdate)
    {
        if(bForceUpdate || !OLib.ConfTera || !OLib.ConfTeraTime || (Date.now()-OLib.ConfTeraTime)>OLib.DeltaConfUpdate*1000)
        {
            if(!Params)
                Params={};
            OLib.ConfTera=await CallTeraProxy(0,"GetConf",Params);
            if(OLib.ConfTera)
            {
                OLib.ConfTeraTime=Date.now();
                FillGates(OLib.ConfTera);
            }
        }

        return OLib.ConfTera;
    }

    function FillGates(Conf)
    {
        OLib.ContractAddr="";
        OLib.NetMapByGate={};
        for(var key in Conf.Gates)
        {
            var Item=Conf.Gates[key];

            var Net=Conf.Blockchains[Item.ChainName];
            if(Net)
            {
                Net.ChainName=Item.ChainName;
                Item.EthNetworkId=Net.EthNetworkId;
                Item.EthSmartAddr=Net.EthSmartAddr;
                Item.OrderEnum=Net.OrderEnum;


                OLib.NetMapByGate[key]=Net;

                if(OLib.EthNetworkId==Net.EthNetworkId)
                    OLib.ContractAddr=Net.EthSmartAddr;

            }
        }
    }


    async function GetOrderListTera(bForceUpdate)
    {
        var Conf=await GetConfTera({},bForceUpdate);
        if(!Conf || !Conf.Orders)
            return [];
        var Orders=Conf.Orders;


        var NextID=Orders.HeadID;

        var Item=OLib.HistoryOrderArrTera[0];
        if(Item.WorkNum===Orders.WorkNum)
            return Item.Arr;
        Item.WorkNum=Orders.WorkNum;

        Item.Arr=[];
        var Arr=Item.Arr;



        while(NextID)
        {
            var Order=await ReadOrderTera(NextID);
            if(Order && Order.ID)
            {
                Arr.push(Order);
            }

            if(Order)
            {
                NextID=Order.NextID;
            }
            else
            {
                NextID=0;
            }

            if(Arr.length>5000)
                break;
        }


        return Arr;
    }


    async function ReadOrderTera(ID)
    {
        if(!OLib.ConfTera)
            return undefined;

        var Order=GetOrderFromMap(OLib.MAP_TERA,ID,async function(ID)
        {
            return await CallTeraProxy(0,"GetOrder",{ID:ID});
        });

        return Order;
    }

    function SetOrderPeriod(Order)
    {
        if(!Order)
            return;

        if(!OLib.ConfTera || !OLib.ConfTera.Common)
        {
            Order.Period="-error-";
            Order.PeriodNum=0;
            return;
        }

        Order.PeriodNum=OrderInPeriod(OLib.ConfTera.Common,Order.ID);
        switch(Order.PeriodNum)
        {
            case 1:
                Order.Period="Waiting";
                break;
            case 2:
                Order.Period="Signing";
                break;
            case 3:
                Order.Period="Checking";
                break;
            case 4:
                Order.Period="Clearing";
                break;
        }
    }

    function GetOrderBlockNum(Order)
    {
        return Math.floor(Order.ID/100000);
    }

    function IsTera(Order)
    {
        var Num=Math.floor(Order.ID/1000);
        if(Num%100 == 0)
            return 1;
        else
            return 0;
    }

    function OrderInPeriod(Info,ID)
    {
        var BlockNum=Math.floor(ID/100000);

        if(INFO.CurBlockNum<BlockNum)
            return 1;


        if(INFO.CurBlockNum>BlockNum+Info.TransferPeriod)
            return 4;

        if(INFO.CurBlockNum>BlockNum+Info.SignPeriod)
            return 3;

        return 2;
    }





    async function CallTera(AccNum,Name,Params,ParamsArr)
    {
        return new Promise(function(resolve, reject)
        {
            StaticCall(AccNum,Name,Params,ParamsArr,function (Err,Value)
            {
                if(Err)
                {
                    SetError(Value);
                    reject(Value);
                }
                else
                {
                    resolve(Value);
                }
            });
        });
    }


    function GetSignOrder(Order,PrivKey)
    {
        var Hash=GetOrderHash(Order);
        return GetSignFromHash(Hash,PrivKey);
    }



    function GetSignFromHash(Hash,PrivKey)
    {
        var Hash32=Buffer.from(Hash);
        var PrivKey32=Buffer.from(PrivKey);
        var Sign = SignLib.sign(Hash32, PrivKey32, null,null);
        var SignArr=[];
        for(var i=0;i<64;i++)
            SignArr.push(Sign.signature[i]);
        SignArr.push(Sign.recovery+27)
        return SignArr;
    }



    //--------------------------------------------------------------------------- common smart-contract lib

    function Round(Sum)
    {
        return Math.floor(0.5+Sum*1e9)/1e9;
    }



    //--------------------------------------------------------------------------- Proxy support
    async function CallTeraProxy(AccNum,Name,Params,ParamsArr)
    {
        return new Promise(function(resolve, reject)
        {
            MStaticCall(AccNum,Name,Params,ParamsArr,function (Err,Value)
            {
                if(Err)
                {
                    SetError(Value);
                    reject(Value);
                }
                else
                {
                    resolve(Value);
                }
            });
        });
    }
    function MStaticCall(To,Name,Params,ParamsArr,F)
    {
        if(typeof Params!=="object")
            return SetError("Error call "+Name);

        Params.cmd=Name;
        if(TESTMODE && To<200 || Name==="GetProxy")
            return StaticCall(To,Name,Params,ParamsArr,F);
        else
            return StaticCall(To,"Call",Params,ParamsArr,F);

    }
    function MSendCall(To,Name,Params,ParamsArr,From)
    {
        if(typeof Params!=="object")
            return SetError("Error call "+Name);

        Params.cmd=Name;
        if(TESTMODE || Name==="SetProxy")
            return SendCall(To,Name,Params,ParamsArr,From);
        else
            return SendCall(To,"Call",Params,ParamsArr,From);
    }

</script>

